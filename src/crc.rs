//! CRC implementations

/// CRC32 implementation used for CD-ROM EDC
///
/// Uses polynomial (x^16 + x^15 + x^2 + 1) * (x^16 + x^2 + x + 1)
pub fn crc32(data: &[u8]) -> u32 {
    data.iter().fold(0, |crc, b| {
        let index = crc as u8 ^ b;
        let x = CRC32_TABLE[index as usize];

        (crc >> 8) ^ x
    })
}

const CRC32_TABLE: [u32; 0x100] = [
    0x0000_0000,
    0x9091_0101,
    0x9121_0201,
    0x01b0_0300,
    0x9241_0401,
    0x02d0_0500,
    0x0360_0600,
    0x93f1_0701,
    0x9481_0801,
    0x0410_0900,
    0x05a0_0a00,
    0x9531_0b01,
    0x06c0_0c00,
    0x9651_0d01,
    0x97e1_0e01,
    0x0770_0f00,
    0x9901_1001,
    0x0990_1100,
    0x0820_1200,
    0x98b1_1301,
    0x0b40_1400,
    0x9bd1_1501,
    0x9a61_1601,
    0x0af0_1700,
    0x0d80_1800,
    0x9d11_1901,
    0x9ca1_1a01,
    0x0c30_1b00,
    0x9fc1_1c01,
    0x0f50_1d00,
    0x0ee0_1e00,
    0x9e71_1f01,
    0x8201_2001,
    0x1290_2100,
    0x1320_2200,
    0x83b1_2301,
    0x1040_2400,
    0x80d1_2501,
    0x8161_2601,
    0x11f0_2700,
    0x1680_2800,
    0x8611_2901,
    0x87a1_2a01,
    0x1730_2b00,
    0x84c1_2c01,
    0x1450_2d00,
    0x15e0_2e00,
    0x8571_2f01,
    0x1b00_3000,
    0x8b91_3101,
    0x8a21_3201,
    0x1ab0_3300,
    0x8941_3401,
    0x19d0_3500,
    0x1860_3600,
    0x88f1_3701,
    0x8f81_3801,
    0x1f10_3900,
    0x1ea0_3a00,
    0x8e31_3b01,
    0x1dc0_3c00,
    0x8d51_3d01,
    0x8ce1_3e01,
    0x1c70_3f00,
    0xb401_4001,
    0x2490_4100,
    0x2520_4200,
    0xb5b1_4301,
    0x2640_4400,
    0xb6d1_4501,
    0xb761_4601,
    0x27f0_4700,
    0x2080_4800,
    0xb011_4901,
    0xb1a1_4a01,
    0x2130_4b00,
    0xb2c1_4c01,
    0x2250_4d00,
    0x23e0_4e00,
    0xb371_4f01,
    0x2d00_5000,
    0xbd91_5101,
    0xbc21_5201,
    0x2cb0_5300,
    0xbf41_5401,
    0x2fd0_5500,
    0x2e60_5600,
    0xbef1_5701,
    0xb981_5801,
    0x2910_5900,
    0x28a0_5a00,
    0xb831_5b01,
    0x2bc0_5c00,
    0xbb51_5d01,
    0xbae1_5e01,
    0x2a70_5f00,
    0x3600_6000,
    0xa691_6101,
    0xa721_6201,
    0x37b0_6300,
    0xa441_6401,
    0x34d0_6500,
    0x3560_6600,
    0xa5f1_6701,
    0xa281_6801,
    0x3210_6900,
    0x33a0_6a00,
    0xa331_6b01,
    0x30c0_6c00,
    0xa051_6d01,
    0xa1e1_6e01,
    0x3170_6f00,
    0xaf01_7001,
    0x3f90_7100,
    0x3e20_7200,
    0xaeb1_7301,
    0x3d40_7400,
    0xadd1_7501,
    0xac61_7601,
    0x3cf0_7700,
    0x3b80_7800,
    0xab11_7901,
    0xaaa1_7a01,
    0x3a30_7b00,
    0xa9c1_7c01,
    0x3950_7d00,
    0x38e0_7e00,
    0xa871_7f01,
    0xd801_8001,
    0x4890_8100,
    0x4920_8200,
    0xd9b1_8301,
    0x4a40_8400,
    0xdad1_8501,
    0xdb61_8601,
    0x4bf0_8700,
    0x4c80_8800,
    0xdc11_8901,
    0xdda1_8a01,
    0x4d30_8b00,
    0xdec1_8c01,
    0x4e50_8d00,
    0x4fe0_8e00,
    0xdf71_8f01,
    0x4100_9000,
    0xd191_9101,
    0xd021_9201,
    0x40b0_9300,
    0xd341_9401,
    0x43d0_9500,
    0x4260_9600,
    0xd2f1_9701,
    0xd581_9801,
    0x4510_9900,
    0x44a0_9a00,
    0xd431_9b01,
    0x47c0_9c00,
    0xd751_9d01,
    0xd6e1_9e01,
    0x4670_9f00,
    0x5a00_a000,
    0xca91_a101,
    0xcb21_a201,
    0x5bb0_a300,
    0xc841_a401,
    0x58d0_a500,
    0x5960_a600,
    0xc9f1_a701,
    0xce81_a801,
    0x5e10_a900,
    0x5fa0_aa00,
    0xcf31_ab01,
    0x5cc0_ac00,
    0xcc51_ad01,
    0xcde1_ae01,
    0x5d70_af00,
    0xc301_b001,
    0x5390_b100,
    0x5220_b200,
    0xc2b1_b301,
    0x5140_b400,
    0xc1d1_b501,
    0xc061_b601,
    0x50f0_b700,
    0x5780_b800,
    0xc711_b901,
    0xc6a1_ba01,
    0x5630_bb00,
    0xc5c1_bc01,
    0x5550_bd00,
    0x54e0_be00,
    0xc471_bf01,
    0x6c00_c000,
    0xfc91_c101,
    0xfd21_c201,
    0x6db0_c300,
    0xfe41_c401,
    0x6ed0_c500,
    0x6f60_c600,
    0xfff1_c701,
    0xf881_c801,
    0x6810_c900,
    0x69a0_ca00,
    0xf931_cb01,
    0x6ac0_cc00,
    0xfa51_cd01,
    0xfbe1_ce01,
    0x6b70_cf00,
    0xf501_d001,
    0x6590_d100,
    0x6420_d200,
    0xf4b1_d301,
    0x6740_d400,
    0xf7d1_d501,
    0xf661_d601,
    0x66f0_d700,
    0x6180_d800,
    0xf111_d901,
    0xf0a1_da01,
    0x6030_db00,
    0xf3c1_dc01,
    0x6350_dd00,
    0x62e0_de00,
    0xf271_df01,
    0xee01_e001,
    0x7e90_e100,
    0x7f20_e200,
    0xefb1_e301,
    0x7c40_e400,
    0xecd1_e501,
    0xed61_e601,
    0x7df0_e700,
    0x7a80_e800,
    0xea11_e901,
    0xeba1_ea01,
    0x7b30_eb00,
    0xe8c1_ec01,
    0x7850_ed00,
    0x79e0_ee00,
    0xe971_ef01,
    0x7700_f000,
    0xe791_f101,
    0xe621_f201,
    0x76b0_f300,
    0xe541_f401,
    0x75d0_f500,
    0x7460_f600,
    0xe4f1_f701,
    0xe381_f801,
    0x7310_f900,
    0x72a0_fa00,
    0xe231_fb01,
    0x71c0_fc00,
    0xe151_fd01,
    0xe0e1_fe01,
    0x7070_ff00,
];

/// Test that the CRC32 table has been correctly generated. In case
/// you wondered where it comes from...
#[test]
fn validate_crc32_table() {
    for i in 0..0x100u32 {
        let mut r = i;

        for _ in 0..8 {
            let x = if r & 1 != 0 {
                // LSB-first code for the polynomial
                0xd801_8001
            } else {
                0
            };

            r = (r >> 1) ^ x;
        }

        assert!(CRC32_TABLE[i as usize] == r);
    }
}

#[test]
fn test_crc32() {
    assert!(crc32(&[]) == 0x0000_0000);
    assert!(crc32(&[0]) == 0x0000_0000);
    assert!(crc32(&[0; 32]) == 0x0000_0000);
    assert!(crc32(&[0xff; 32]) == 0xfb01_bffe);
    assert!(crc32(b"Rustation 4ever") == 0x723f_8ba9);
}

/// CRC16 implementation used for Q subchannel (CRC-16-CCITT)
pub fn crc16(data: &[u8]) -> u16 {
    !data.iter().fold(0, |crc, &b| {
        let index = (crc >> 8) ^ u16::from(b);
        let x = CRC16_TABLE[index as usize];

        (crc << 8) ^ x
    })
}

/// CRC16 CCITT
const CRC16_TABLE: [u16; 0x100] = [
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0xa14a, 0xb16b,
    0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401,
    0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738,
    0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5, 0x4ad4, 0x7ab7, 0x6a96,
    0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd,
    0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca, 0xa1eb,
    0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1, 0x1290, 0x22f3, 0x32d2,
    0x4235, 0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8,
    0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827,
    0x18c0, 0x08e1, 0x3882, 0x28a3, 0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d,
    0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74,
    0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
];

#[test]
fn validate_crc16_table() {
    for (i, &e) in CRC16_TABLE.iter().enumerate() {
        let mut r = (i as u16) << 8;

        for _ in 0..8 {
            let x = if r & 0x8000 != 0 { 0x1021 } else { 0 };

            r = (r << 1) ^ x;
        }

        assert_eq!(e, r);
    }
}

#[test]
fn test_crc16_rw_raw() {
    // Random Metal Gear Solid 1 raw subchannel data dumped with cdrdao
    let raw_rw: [[u8; 96]; 3] = [
        [
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
            0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
            0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
            0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40,
        ],
        [
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
            0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
            0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x40, 0x40,
            0x00, 0x40, 0x00, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x40,
        ],
        [
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40,
            0x00, 0x00, 0x00, 0x00, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
            0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
            0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40,
            0x40, 0x00, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
        ],
    ];

    for raw in raw_rw.iter() {
        // Extract subchannel Q from the raw data
        let mut subq = [0u8; 12];
        for (bit, &r) in raw.iter().enumerate() {
            // Subchannel Q is in bit 7
            let v = (r & 0x40) != 0;

            if !v {
                continue;
            }

            subq[bit / 8] |= 1 << (7 - (bit & 7));
        }

        println!("{:x?}", subq);

        let crc = crc16(&subq[..10]);
        assert_eq!(crc.to_be_bytes(), subq[10..12]);
    }
}
